
\chapter{Teste\label{chap:Teste}}

\lhead{\thechapter - Teste} 

Neste capítulo será validado os resultados do simulador utilizando
solução da equação do calor para coordenadas cartesianas de uma dimensão.

Também será apresentado soluções aplicados à indústria do petróleo,
como injeção de calor em reservatório, e aplicações na engenharia
em geral, como resfriamento de computadores.

\section{Teste 1: Validação do simulador}

Para validar os resultados do simulador, será comparado os resultados
do simulador, com a solução proposta no \cite{incropera2008fundamentos},
na página 179, equação (5.57). A solução para o caso unidimensional
é:

\begin{equation}
\frac{T-T_{s}}{T_{i}-T_{s}}=erf\left(\frac{x}{2\sqrt{\alpha t}}\right)\label{eq:solucao analitica}
\end{equation}

Onde erf é a \textit{função erro de Gauss}, e $\alpha$ é a constante
com as propriedades termofísicas:

\begin{equation}
\alpha=\frac{k}{\rho C_{p}}
\end{equation}

As soluções horizontais e verticais do simulador são salvas em uma
pasta em arquivos '.txt', com o respectivo tempo no nome do arquivo.

Foi programado um código em python para comparar dois resultados do
simulador com a solução da equação \ref{eq:solucao analitica}, apresentado
abaixo:

\lstdefinestyle{C++}{
% tipo de bordas
frame=lines,
% tamanho da fonte e tipo de fonte
basicstyle=\small\ttfamily,
% linguagem
language=[ISO]C++,
% numeração
numbers=left, 
numberstyle=\tiny, 
stepnumber=1, 
numbersep=1pt, 
firstnumber=1, 
% formatação
breakatwhitespace=false,
breaklines=true,
extendedchars=true,
% cores
backgroundcolor=\color{white},
commentstyle=\color{lightgray}, 
keywordstyle=\color{blue},
morekeywords={*,...}, 
stringstyle=\color{mygreen1},
%
% Palavras chave BLUE
emph={ bool, char, char8_t, char16_t, char32_t, wchar_t,short, int, long, long long, float, double, long double, void, const, extern, mutable, register, signed, static, typedef, unsigned, volatile, using, typename, auto, constexpr, decltype, class, enum, struct, union, const_cast, dynamic_cast, reinterpret_cast, static_cast, try, throw, catch, noexcept, delete, new, nullptr, static, const, friend, virtual, operator, namespace, sizeof, template, typename, concept, class,  delete, friend, explicit, this, typeid, private, protected, public, alignas, alignof, asm, concept, consteval, constexpr, constinit export, extern, inline, static_assert, requires, template, typename, mutable,  volatile, co_await, co_return, co_yield, atomic_cancel, atomic_commit, atomic_noexcept, import, module, synchronized,co_await, co_return, co_yield, reflexpr }, 
emphstyle={\color{blue}},
%
% Estruturas de controle e de repeticao RED
emph={[2] and, and_eq, bitand, bitor, compl, false, not, not_eq, or, or_eq, true, xor, xor_eq, break, case, continue, default, do, else, for, goto, if, return, switch, while  } ,
emphstyle={[2]\color{red}},
%
% Arquivos de inclusao mymauve (note que alguns poderao aparecer com outra cor, ocorre quando nome arquivo igual ao nome da classe)
emph={[3] algorithm , atomic ,backward ,bits ,bitset ,cassert ,ccomplex ,cctype ,cerrno ,cfenv ,cfloat ,chrono ,cinttypes ,ciso646 ,climits ,clocale ,cmath ,complex ,csetjmp ,csignal ,cstdalign ,cstdarg ,cstdbool ,cstddef ,cstdint ,cstdio ,cstdlib ,cstring ,ctgmath ,ctime ,cwchar ,cwctype ,debug ,decimal ,exception ,ext ,filesystem, fstream ,functional  ,initializer_list ,iomanip ,ios ,iosfwd ,iostream ,istream ,iterator ,limits ,locale ,numeric ,ostream ,profile ,random ,ratio ,regex ,scoped_allocator ,sstream ,stack ,stdexcept  ,streambuf ,system_error ,tr1 ,tr2 ,typeindex ,typeinfo ,type_traits ,utility ,x86_64-redhat-linux ,complex } , 
emphstyle={[3]\color{green}},
%
% Strings VERDE2
emph={[4] string, string_view, wstring, u16string,u32string } ,
emphstyle={[4]\color{mygreen2}\bfseries},
%
% Containers purple
emph={[5]  array, vector, deque, forward_list, list, set, multiset, map, multimap, unordered_set, unordered_multiset, unordered_map, unordered_multimap , pair, tuple, basic_string },
emphstyle={[5]\color{brown}\bfseries},
%
%Algoritmos genericos VERMELHO2
emph={[6]  accumulate, find, max, adjacent_find, find_if, max_element, binary_search, min, count, find_first_of, for_each, min_element, count_if, includes, mismatch, equal, lexicographical_compare, nth_element, equal_range, lower_bound, mismatch, search, search_n, find_end, upper_bound, copy, remove_if, copy_backward, replace, fill, replace_copy, fill_n, replace_copy_if, generate, replace_if, generate_n, reverse, inplace_merge, reverse_copy, iter_swap, rotate,  make_heap, rotate_copy, merge, set_difference, nth_element, next_permutation, set_intersection, set_symmetric_difference, partial_sort, set_union, partial_sort_copy, sort, partition, sort_heap, prev_permutation, stable_partition, push_heap, stable_sort, pop_heap, swap, random_shuffle, swap_ranges, remove, transform, unique, unique_copy, remove_copy, remove_copy_if, all_of, any_of, none_of, find_if_not, copy_if, copy_n, move, move_backward, suffle, is_partitioned, partition_copy, partition_point, is_sorted, is_sorted_until, is_heap, is_heap_until, minmax, minmax_element, is_permutation, iota, uninitialized_copy_n, for_each_n, sample, clamp, reduce, exclusive_scan, inclusive_scan, transform_reduce, transform_exclusive_scan, transform_inclusive_scan, uninitialized_move, uninitialized_move_n, uninitialized_default_construct, uninitialized_default_construct_n, uninitialized_value_construct, uninitialized_value_construct_n, destroy, destroy_at, destroy_n, shift_left, shift_right, compare_3way, lexicographical_compare_3way } ,
emphstyle={[6]\color{olive}},
%
% Processamento Paralelo Orange/laranja
emph={[7] thread, yield, get_id, sleep_for, sleep_until, thread_local, memory, mutex, parallel, mutex, timed_mutex, recursive_mutex, shared_mutex, shared_timed_mutex, lock_guard, scoped_lock, unique_lock, shared_lock, defer_lock_t, try_to_lock_t, adopt_lock_t, try_lock, lock, once_flag, call_once, condition_variable, condition_variable_any, notify_all_at_thread_exit, cv_status, promise, packaged_task, future, shared_future, async, launch, future_status, future_error, future_category, future_errc, hardware_destructive_interference_size, hardware_constructive_interference_size  } ,
emphstyle={[7]\color{mymauve}},
}

\lstset{style=C++} \lstinputlisting[ caption={Arquivo de implementação da validação.}, label={validacao}] {../SimuladorTemperatura/save_results_validacao/validacao.py}

Como resultado, o código acima apresenta o gráfico , comparando dois
tempos 50 e 100 segundos.

\begin{figure}[H]
\begin{centering}
\includegraphics[scale=0.7]{../imagens/validacao}
\par\end{centering}
\caption{Comparação da solução da equação de calor com o resultado do simulador.}

\end{figure}

Os dados acima foram obtidos utilizando um material com propriedades
termofísicas constantes, apresentadas na tabela abaixo:
\begin{center}
\begin{tabular}{|c|c|}
\hline 
Propriedade & Valor\tabularnewline
\hline 
\hline 
$C_{p}$ & 40.000\tabularnewline
\hline 
k & 40\tabularnewline
\hline 
$\rho$ & 1.600\tabularnewline
\hline 
\end{tabular}
\par\end{center}

O erro do simulador foi menor que 1.06\%, para o tempo de 50,0 segundos,
e para 500 iterações. 

É importante mencionar que o número de iterações deve ser alta, pois
o método iterativo BTCS, só consegue 'avançar' uma única célula por
iteração. Ou seja, o número mínimo de iterações deve ser maior que
o número de células na vertical ( número de células na vertical é
maior que na horizontal).

\section{Resultados: injeção de calor em reservatório - modelo 1}

A seguir, é apresentado uma simulação para injeção térmica em um reservatório
de petróleo com camadas, onde o poço está injetando calor com condutividade
infinite e com penetração parcial.

As propriedades termofísicas utilizadas para a rocha são:
\begin{center}
\begin{tabular}{|c|c|}
\hline 
Propriedade & Valor\tabularnewline
\hline 
\hline 
$C_{p}$ & 920\tabularnewline
\hline 
k & 1.6\tabularnewline
\hline 
$\rho$ & 2.600\tabularnewline
\hline 
\end{tabular}
\par\end{center}

As propriedades do poço são:
\begin{center}
\begin{tabular}{|c|c|}
\hline 
Propriedade & Valor\tabularnewline
\hline 
\hline 
$C_{p}$ & 593\tabularnewline
\hline 
k & 10,33\tabularnewline
\hline 
$\rho$ & 8.020\tabularnewline
\hline 
\end{tabular}
\par\end{center}

O teste busca analisar como é a transferência de calor na região próxima
ao poço, considerando injeção de água, e com a formação de \textit{fingers}. 

\begin{figure}[H]
\begin{centering}
\includegraphics[width=0.75\textwidth]{../imagens/reservatorio_t0.PNG}
\par\end{centering}
\caption{Tempo inicial da simulação. Na esquerda, o cinza representa o poço,
azul a água e o amarelo, arenito. Na direita, é mostrado as temperaturas.}
\end{figure}

Com a evolução do tempo, a região mais próxima do poço é a mais alterada.

\begin{figure}[H]
\begin{centering}
\includegraphics[width=0.75\textwidth]{../imagens/reservatorio_t610.PNG}
\par\end{centering}
\caption{Evolução da simulação. Tempo de 610 segundos.}
\end{figure}

Com a evolução do tempo, é possível perceber que a região próxima
ao poço fica com temperatura quase homogênea, começando a se espalhar
para o restante do reservatório.
\begin{figure}[H]
\begin{centering}
\includegraphics[width=0.75\textwidth]{../imagens/reservatorio_tfinal.PNG}
\par\end{centering}
\caption{Tempo final de 7.180 segundos.}
\end{figure}
\begin{figure}[H]
\begin{centering}
\includegraphics[width=0.85\textwidth]{../imagens/reservatorio_tfinal_graficos.PNG}
\par\end{centering}
\caption{Gráficos do tempo final de 7.180 segundos.}
\end{figure}


\section{Resultados: Injeção de calor em reservatório - modelo 2}

Para a segunda simulação, será utilizado um modelo semelhante ao modelo
1, mas sem a injeção de água, conforme mostrado na figura 
\begin{figure}[H]
\begin{centering}
\includegraphics[width=0.9\textwidth]{../imagens/reservatorio_modelo2.PNG}
\par\end{centering}
\caption{Modelo 2 de injeção térmica em reservatório.\label{fig:Teste_reservatorio_sem_agua}}
\end{figure}

Com esse modelo, é esperado que a variação de temperatura não atinja
regiões distantes do reservatório, devido à baixa condutividade térmica
do arenito.

\begin{figure}[H]
\begin{centering}
\includegraphics[width=0.85\textwidth]{../imagens/reservatorio_modelo2_resultado.PNG}
\par\end{centering}
\caption{Modelo 2 de injeção térmica em reservatório após 4.000 segundos.\label{fig:Teste_reservatorio_sem_agua-2}}
\end{figure}

\begin{figure}[H]
\begin{centering}
\includegraphics[width=0.85\textwidth]{../imagens/reservatorio_modelo2_graficos.PNG}
\par\end{centering}
\caption{Graficos mostrando a variação de temperatura na região próxima ao
poço.\label{fig:Teste_reservatorio_sem_agua-3}}
\end{figure}

A comparação dos dois modelos mostra como efetivo é a injeção de água
com temperatura elevada para aquecer o reservatório. Sem injeção de
água, a temperatura não consegue atingir regiões distantes devido
a baixa condutividade térmica do arenito.

\section{Resultados: resfriamento de processadores}

Processadores são componentes elétricos de mais alta importância e
complexidade do mundo moderno. São responsáveis por realizar numerosas
operações matemáticas em curtíssimos espaços de tempo. Mas esse alto
poder de processamento causa uma elevada geração de calor, a qual
pode atrapalhar ou queimar o componente.

Então, para evitar danos no componente, foram criados diversos mecanismos
de resfriamentos, como \textit{air coolers} e \textit{water coolers.
}Esse problema fica complexo, quando é analisado equipamentos reduzidos,
como \textit{smartphones} e \textit{notebooks.}

Na figura \ref{fig:Teste_notebook}, é mostrado o interior de um \textit{notebook.
}É possível perceber uma longa barra de cobre, cruzando pela GPU e
CPU, os componentes com maior processamento e geração de calor.

\begin{figure}[H]
\begin{centering}
\includegraphics[width=0.8\textwidth]{../imagens/notebook.jpeg}
\par\end{centering}
\caption{Interior de um \textit{notebook}, apresentando o \textit{heatpipe,}
que é a barra de cobre que cruza a GPU e CPU, e resfria na ventoinha.\label{fig:Teste_notebook}}
\end{figure}

Utilizando o simulador, é possível simular o caso acima, utilizando
cobre com propriedades constantes como material.
\begin{center}
\begin{tabular}{|c|c|}
\hline 
Propriedade & Valor\tabularnewline
\hline 
\hline 
$C_{p}$ & 353\tabularnewline
\hline 
k & 42\tabularnewline
\hline 
$\rho$ & 7.262\tabularnewline
\hline 
\end{tabular}
\par\end{center}

Na figura \ref{fig:Teste_notebook2}, é apresentado o modelo do resfriador.
onde o grid 0, possui as fontes de calor (GPU, CPU), e a fonte de
resfriamento acima (ventoinha). No grid 1, é mostrado o \textit{heatpipe},
interligando os componentes, e chegando à ventoinha.

\begin{figure}[H]
\begin{centering}
\includegraphics[width=0.9\textwidth]{../imagens/resultado_temp_notebook.PNG}
\par\end{centering}
\caption{Simulação do sistema de resfriamento do notebook após chegar ao período
permanente.\label{fig:Teste_notebook2}}
\end{figure}

Na figura \ref{fig:Teste_notebook3}, são apresentados os gráficos
da temperatura ao longo da horizontal (esquerda) e vertical (direita).
\begin{figure}[H]
\begin{centering}
\includegraphics[width=0.8\textwidth]{../imagens/teste_graficos_notebook.PNG}
\par\end{centering}
\caption{Interior de um \textit{notebook}, apresentando o \textit{heatpipe,}
que é a barra de cobre que cruza a GPU e CPU, e resfria na ventoinha.\label{fig:Teste_notebook3}}
\end{figure}

A temperatura é rapidamente dispersada quando chega à ventoinha, resultando
em duas quedas de temperatura, indicando que o componente do meio
(CPU) na simulação, deveria estar mais próximo do outro componente
(GPU), para que a queda de temperatura seja linear, evitando o super-aquecimento
de uma das partes.
